server default {

listen {
	type = auth

	# ipv4addr = *
	# ipv6addr = *
	ipaddr = *

	port = 0

	interface = eth0
#	clients = per_socket_clients

	limit {
		  max_connections = 16

		  lifetime = 0
		  idle_timeout = 30
	}
}

listen {
	type = auth

	ipv4addr = 127.0.0.1
	# ipv6addr = *
	port = 0
	interface = lo
#	clients = per_socket_clients
	limit {
		  max_connections = 16
		  lifetime = 0
		  idle_timeout = 30
	}
}


#
#  This second "listen" section is for listening on the accounting
#  port, too.
#
listen {
	ipaddr = *
#	ipv6addr = ::
	port = 0
	type = acct
	interface = eth0
#	clients = per_socket_clients

	limit {
#		max_pps = 0

#		idle_timeout = 0
#		lifetime = 0
#		max_connections = 0
	}
}

listen {
	ipaddr = 127.0.0.1
	port = 0
	type = acct
	interface = lo
#	clients = per_socket_clients
	limit {
	}
}




authorize {
	#filter_username

	#filter_password

	preprocess

#	operator-name

#	cui

#	auth_log

	#chap

	#mschap

	#digest

#	wimax

#	IPASS

	#suffix
#	ntdomain

	#eap {
	#	ok = return
#		updated = return
	#}

#	unix

	#
	#  Read the 'users' file.  In v3, this is located in
	#  raddb/mods-config/files/authorize
	#files

	#-sql

#	smbpasswd

	#
	#  The ldap module reads passwords from the LDAP database.
	#-ldap

	#  Enforce daily limits on time spent logged in.
#	daily

	#
	expiration
	logintime

	#pap

	acct_unique


	#if (&User-Password) {
	#	update control {
	#		Auth-Type = rest
	#	}
	#}

	update control {
		&REST-HTTP-Header := "Content-Type: application/json"
	}

	# DEBUG
	# Customer 151412
	#update request {
	#	&ADSL-Agent-Remote-Id := 0x00061c8779142633
	#	&ADSL-Agent-Circuit-Id := 0x000074000719
	#	&ERX-Dhcp-Mac-Addr := "00:50:79:66:68:00"
	#	&NAS-Port-Id := 999
	#}

	rest

	if (updated) {
		ok
	}

	if (ok) {
		update control {
			Auth-Type := Accept
		}
		update reply {
			# Juniper
			&Acct-Interim-Interval := 7200
			&Port-Limit := 1
			&ERX-Primary-DNS := 10.12.1.9
			&ERX-Secondary-DNS = 77.88.8.8
			&ERX-Service-Activate:1 += "%{reply:User-Password}"

			# Mikrotik
			# &Mikrotik-Rate-Limit := "100M/100M"
			#&Mikrotik-Host-IP = 172.16.3.8
			#&Framed-IP-Address = 172.16.3.198
			#&Framed-IP-Netmask = 255.255.255.0
			#&ERX-Primary-DNS := 10.12.1.9
			#&Mikrotik-Address-List := DjingUsersAllowed
			#&DHCP-NTP-Servers := 10.12.1.9

			User-Password !* ANY
		}

		if (!&reply:Session-Timeout) {
			update reply {
				Session-Timeout := 21600 # 6h
			}
		}
	} elsif (userlock || notfound) {
		# Return guest poo name
		update control {
			Auth-Type := Accept
			&Pool-Name := "guest"
		}
	} else {
		reject
	}

	if (reject) {
		update control {
			Auth-Type := Reject
		}
	}
}


#  Authentication.
#
authenticate {
	#python

	#Auth-Type PAP {
	#	pap
	#}

	#
	#digest

	#
	#  Pluggable Authentication Modules.
#	pam

	#
	#  Allow EAP authentication.
	#eap

	#Auth-Type rest {
	#	rest {
	#		updated = 1
	#	}
	#	if (updated) {
	#		ok
	#	} else {
	#		reject
	#	}
	#}
}


preacct {
	#preprocess

	#acct_counters64

	#update request {
	#  	&FreeRADIUS-Acct-Session-Start-Time = "%{expr: %l - %{%{Acct-Session-Time}:-0} - %{%{Acct-Delay-Time}:-0}}"
	#}

	acct_unique

#	IPASS
	#suffix
#	ntdomain

	#
	#  Read the 'acct_users' file
	#files
}

accounting {
#	cui
#	daily

	#unix

#	radutmp
#	sradutmp

#	main_pool

	#-sql

	#if (noop) {
	#	ok
	#}

	#  Cisco VoIP specific bulk accounting
#	pgsql-voip

	# For Exec-Program and Exec-Program-Wait
	#exec

	#  Filter attributes from the accounting response.
	#attr_filter.accounting_response

	#
	#  See "Autz-Type Status-Server" for how this works.
	#
#	Acct-Type Status-Server {
#
#	}

	# DEBUG
	# Customer 151412
	#update request {
	#	&ADSL-Agent-Remote-Id := 0x00061c8779142633
	#	&ADSL-Agent-Circuit-Id := 0x000074000719
	#	&ERX-Dhcp-Mac-Addr := "00:50:79:66:68:00"
	#	&NAS-Port-Id := 999
	#}

	update control {
		#&Auth-Type := "Accept"
		&REST-HTTP-Header := "Content-Type: application/json"
	}
	#redis
	rest

	#if (updated) {
	#	ok
	#}

	#if (ok) {
	#	update control {
	#		Auth-Type := Accept
	#	}
	#} else {
	#	reject
	#}

	#if (reject) {
	#	update control {
	#		Auth-Type := Reject
	#	}
	#}
	ok
}


session {
#	radutmp

#	sql
}


post-auth {
	#
	#  If you need to have a State attribute, you can
	#  add it here.  e.g. for later CoA-Request with
	#  State, and Service-Type = Authorize-Only.
	#
#	if (!&reply:State) {
#		update reply {
#			State := "0x%{randstr:16h}"
#		}
#	}


	#update control {
	#	&Pool-Name := "v152_10_152_32_0_20"
	#	#Pool-Name = "guest"
	#}
	#update request {
	#	&NAS-Port-Id := 145
	#}
	Post-Auth-Type REJECT {
		update control {
			Pool-Name = "guest"
		}
		ok
	}

	if (control:Pool-Name && control:Pool-Name == "guest") {
		guest
	} else {
		# Calc pool by vlan if it exists
		if (!control:Pool-Name && request:NAS-Port-Id) {
			python
		}
		#  Get an address from the IP Pool.
		$INCLUDE ../mods-enabled/pool_list.conf
	}
}
}
